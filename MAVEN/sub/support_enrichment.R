#Copyright (C) 2020  Aurelien Dugourd, Alberto Valdeolivas, Rosa Hernansaiz-Ballesteros
#Contact : aurelien.dugourd@bioquant.uni-heidelberg.de

#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.

library(piano)
library(parallel)
library(GSEABase)
library(snowfall)
library(readr)


#'\code{gmt_to_csv}
#'
#'This function is designed to convert a gmt file into a two column dataframe where first column correspond to omic features and second column correspond to associated terms.
#'
#'@param gmtfile a full path name of the gmt file to be converted
#'@param outfile an optional output file name. If none is provided, the function will simply return a dataframe.
#'If outfile is provided with a full length path name file, the dataframe will be written as a csv file to the path provided.
#'@return a two column dataframe where first column correspond to omic features and second column correspond to associated terms.
gmt_to_csv <- function(gmtfile, fast = T)
{
  if(fast)
  {
    genesets = GSEABase::getGmt(con = gmtfile)
    genesets = unlist(genesets)
    
    gene_to_term =plyr::ldply(genesets,function(geneset){
      temp <- geneIds(geneset)
      temp2 <- setName(geneset)
      temp3 <- as.data.frame(cbind(temp,rep(temp2,length(temp))))
      
    },.progress = plyr::progress_text())
    names(gene_to_term) <- c("gene","term")
    return(gene_to_term[complete.cases(gene_to_term),])
  }
  else
  {
    genesets = getGmt(con = gmtfile)
    genesets = unlist(genesets)
    
    gene_to_term <- data.frame(NA,NA)
    names(gene_to_term) <- c("gene","term")
    for (geneset in genesets)
    {
      temp <- geneIds(geneset)
      temp2 <- setName(geneset)
      temp3 <- as.data.frame(cbind(temp,rep(temp2,length(temp))))
      names(temp3) <- c("gene","term")
      gene_to_term <- rbind(gene_to_term,temp3)
    }
    
    return(gene_to_term[complete.cases(gene_to_term),])
  }
}


#'\code{extractCARNIVALnodes}
#'
#'Function to extract the nodes that appear in CARNIVAL network and the
#'background genes (all genes present in the prior knowledge network).
#'
#'@param CarnivalResults CARNIVAL output.
#'@return List with 2 objects the success and the background genes.
extractCARNIVALnodes <- function(CarnivalResults){
  
  CarnivalNetwork <- 
    as.data.frame(CarnivalResults$weightedSIF, stringsAsFactors = FALSE)
  
  colnames(CarnivalNetwork) <- c("source", "sign", "target", "Weight")
  
  ## We define the set of nodes interesting for our condition
  sucesses <- unique(c(gsub("_.*","",CarnivalNetwork$source), 
                       gsub("_.*","",CarnivalNetwork$target)))
  
  CarnivalAttributes <- as.data.frame(CarnivalResults$nodesAttributes, 
                                      stringsAsFactors = FALSE)
  
  ## We define the background as all the genes in our prior knowledge network.
  bg <- unique(gsub("_.*","",CarnivalAttributes$Node))     
  
  return(list(sucesses = sucesses, bg= bg))
}


#'\code{runPIANO}
#'
#'This function serves as a wrapper for the piano pipeline.
#'It's design to simplify the use of piano while reducing the flexibility of the method (no more choice of methods).
#'
#'@param topTable a topTable such as (but not necessarily) generated by limma. It should have a column for omic features IDs (genes, proteins...),
#'a column for fold changes, a column for pValues and a column for Tvalues.
#'@param gene_to_term a gene to term data frame, where the first column correspond to omic features identifiers (they have to be coherent with the identifiers of the topTable).
#'The second columns should correspond to the terms associated with the omic features.
#'@param nCores The number of cores that should be used. If the number is set higher than the actual number of available cpus, the actual number of available cpus will be used.
#'@param IDIndex The column number corresponding to omic feature IDs
#'@param FCIndex The column number corresponding to omic feature fold changes
#'@param PvalIndex The column number corresponding to omic feature p-values
#'@param Tval The column number corresponding to omic feature t-values
#'@param nPerm The expected number of permutation to generate null distributions. This number will be automaticly adjusted to the closest smaller number allowing that there is an integer x such that x*nCores=nPerm.
#'@return a list of three elements. The first element is the consensus enrichment table. The second element if the consensus heatmap object returned by the consensusHeatmap function of piano. The third element is the list of results returned by the runGSA functions of piano.
#'
runPIANO <- function(topTable, gene_to_term, nCores = 1000, IDIndex = 1, FCIndex = 2, PvalIndex = 5, TvalIndex = 4, nPerm = 10000)
{
  
  nCores <- min(c(nCores,detectCores()-1))
  
  print(paste(nCores, " cpu(s) will be used."), sep = "")
  
  topTable <- as.data.frame(topTable)
  
  gene_to_term <- as.data.frame(gene_to_term)
  gene_to_term[,1] <- toupper(gene_to_term[,1])
  gene_to_term[,2] <- toupper(gene_to_term[,2])
  #print(head(gene_to_term))
  geneSet <- loadGSC(gene_to_term)
  
  myFC <- topTable[,FCIndex]
  names(myFC) <- toupper(topTable[,IDIndex])
  
  myPval <- topTable[,PvalIndex]
  names(myPval) <- toupper(topTable[,IDIndex])
  
  myTval <- topTable[,TvalIndex]
  names(myTval) <- toupper(topTable[,IDIndex])
  
  nPerm <- nPerm-nPerm%%nCores
  
  print(paste(as.character(nPerm), " permutations will be made (so that there is an integer x such that x*nCores=nPerm)", sep = ""))
  
  ###Run the GSA
  gsaRes1 <- runGSA(myTval, gsc=geneSet, adjMethod = "fdr", geneSetStat = "mean", ncpus = nCores, nPerm = nPerm)
  #gsaRes1 <- runGSA(myTval, gsc=geneSet, adjMethod = "fdr", geneSetStat = "mean")
  gsaRes2 <- runGSA(myTval, gsc=geneSet, adjMethod = "fdr", geneSetStat = "median", ncpus = nCores, nPerm = nPerm)
  gsaRes3 <- runGSA(myTval, gsc=geneSet, adjMethod = "fdr", geneSetStat = "sum", ncpus = nCores, nPerm = nPerm)
  gsaRes4 <- runGSA(myTval, gsc=geneSet, adjMethod = "fdr", geneSetStat = "maxmean", ncpus = nCores, nPerm = nPerm)
  gsaRes5 <- runGSA(geneLevelStats = myPval, directions = myFC, gsc=geneSet, adjMethod = "fdr", geneSetStat = "fisher", ncpus = nCores, nPerm = nPerm)
  gsaRes6 <- runGSA(geneLevelStats = myPval, directions = myFC, gsc=geneSet, adjMethod = "fdr", geneSetStat = "stouffer", ncpus = nCores, nPerm = nPerm)
  gsaRes7 <- runGSA(geneLevelStats = myPval, directions = myFC, gsc=geneSet, adjMethod = "fdr", geneSetStat = "tailStrength", ncpus = nCores, nPerm = nPerm)
  gsaRes8 <- runGSA(geneLevelStats = myPval, directions = myFC, gsc=geneSet, adjMethod = "fdr", geneSetStat = "wilcoxon", ncpus = nCores, nPerm = nPerm)
  gsaRes9 <- runGSA(myTval, gsc=geneSet, adjMethod = "fdr", geneSetStat = "page", ncpus = nCores, nPerm = nPerm)
  gsaRes10 <- runGSA(geneLevelStats = myPval, directions = myFC, gsc=geneSet, adjMethod = "fdr", geneSetStat = "reporter", ncpus = nCores, nPerm = nPerm)
  gsaRes11 <- runGSA(myTval, gsc=geneSet, adjMethod = "fdr", geneSetStat = "fgsea", ncpus = nCores, nPerm = nPerm)
  
  resList <- list(gsaRes1,gsaRes2,gsaRes3,gsaRes4,gsaRes5,gsaRes6,gsaRes7,gsaRes8,gsaRes9,gsaRes10,gsaRes11)
  names(resList) <- c("mean","median","sum","maxmean","fisher", "stouffer","tailStrength","wilcoxon","page", "reporter","fgsea")
  
  ch <- consensusHeatmap(resList,cutoff=50000,method="median", ncharLabel = 1000, cellnote = "medianPvalue", cex = 0.2, plot = FALSE) ##The results are strange
  
  consensus <- ch$pMat
  
  return(list(consensus,ch,resList))
}

runPIANO_pValOnly <- function(topTable, gene_to_term, nCores = 1000, IDIndex = 1, FCIndex = 2, PvalIndex = 5, nPerm = 10000)
{
  
  nCores <- min(c(nCores,detectCores()-1))
  
  print(paste(nCores, " cpu(s) will be used."), sep = "")
  
  topTable <- as.data.frame(topTable)
  
  gene_to_term <- as.data.frame(gene_to_term)
  gene_to_term[,1] <- toupper(gene_to_term[,1])
  gene_to_term[,2] <- toupper(gene_to_term[,2])
  #print(head(gene_to_term))
  geneSet <- loadGSC(gene_to_term)
  
  myFC <- topTable[,FCIndex]
  names(myFC) <- toupper(topTable[,IDIndex])
  
  myPval <- topTable[,PvalIndex]
  names(myPval) <- toupper(topTable[,IDIndex])
  
  myTval <- topTable[,TvalIndex]
  names(myTval) <- toupper(topTable[,IDIndex])
  
  nPerm <- nPerm-nPerm%%nCores
  
  print(paste(as.character(nPerm), " permutations will be made (so that there is an integer x such that x*nCores=nPerm)", sep = ""))
  
  ###Run the GSA
  gsaRes5 <- runGSA(geneLevelStats = myPval, directions = myFC, gsc=geneSet, adjMethod = "fdr", geneSetStat = "fisher", ncpus = nCores, nPerm = nPerm)
  gsaRes6 <- runGSA(geneLevelStats = myPval, directions = myFC, gsc=geneSet, adjMethod = "fdr", geneSetStat = "stouffer", ncpus = nCores, nPerm = nPerm)
  gsaRes7 <- runGSA(geneLevelStats = myPval, directions = myFC, gsc=geneSet, adjMethod = "fdr", geneSetStat = "tailStrength", ncpus = nCores, nPerm = nPerm)
  gsaRes8 <- runGSA(geneLevelStats = myPval, directions = myFC, gsc=geneSet, adjMethod = "fdr", geneSetStat = "wilcoxon", ncpus = nCores, nPerm = nPerm)
  gsaRes10 <- runGSA(geneLevelStats = myPval, directions = myFC, gsc=geneSet, adjMethod = "fdr", geneSetStat = "reporter", ncpus = nCores, nPerm = nPerm)
  
  resList <- list(gsaRes5,gsaRes6,gsaRes7,gsaRes8,gsaRes10)
  names(resList) <- c("fisher", "stouffer","tailStrength","wilcoxon", "reporter")
  
  ch <- consensusHeatmap(resList,cutoff=50000,method="median", ncharLabel = 1000, cellnote = "medianPvalue", cex = 0.2, plot = FALSE) ##The results are strange
  
  consensus <- ch$pMat
  
  return(list(consensus,ch,resList))
}